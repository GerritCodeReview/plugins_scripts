{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "371ad673_ef4a8ac6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 9,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "Just say: \"Add a new Groovy script ...\"",
      "range": {
        "startLine": 9,
        "startChar": 48,
        "endLine": 9,
        "endChar": 68
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec02573a_a0cc0e3e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 9,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-18T13:53:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "371ad673_ef4a8ac6",
      "range": {
        "startLine": 9,
        "startChar": 48,
        "endLine": 9,
        "endChar": 68
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fa8306d_bbc277a5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 16,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "Clever idea indeed! Have you measured the performance impact _just-in-case_ ?",
      "range": {
        "startLine": 15,
        "startChar": 12,
        "endLine": 16,
        "endChar": 39
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb94dc9a_6b3e3690",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 16,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-18T13:53:00Z",
      "side": 1,
      "message": "Nope, I have not measured the performance impact, but it should be neglectable, and equal to the performance of the `PersistentCache.put()` operation.\n\nI can add this to the commit message if you think it\u0027s helpful.",
      "parentUuid": "5fa8306d_bbc277a5",
      "range": {
        "startLine": 15,
        "startChar": 12,
        "endLine": 16,
        "endChar": 39
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08611c4a_23a7243c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 16,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-19T23:54:33Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "bb94dc9a_6b3e3690",
      "range": {
        "startLine": 15,
        "startChar": 12,
        "endLine": 16,
        "endChar": 39
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1c7709e_40d7362a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 16,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-20T09:36:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "08611c4a_23a7243c",
      "range": {
        "startLine": 15,
        "startChar": 12,
        "endLine": 16,
        "endChar": 39
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1878b5e8_e2a2b846",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 17,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "Nit: wrap long line",
      "range": {
        "startLine": 17,
        "startChar": 69,
        "endLine": 17,
        "endChar": 74
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "136f13bb_b86a00f5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 17,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-18T13:53:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1878b5e8_e2a2b846",
      "range": {
        "startLine": 17,
        "startChar": 69,
        "endLine": 17,
        "endChar": 74
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29a5b023_b43c1fa1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 20,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "Nit: wrap long line",
      "range": {
        "startLine": 20,
        "startChar": 61,
        "endLine": 20,
        "endChar": 74
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "64cd1137_e6aa3e7b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 20,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-18T13:53:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "29a5b023_b43c1fa1",
      "range": {
        "startLine": 20,
        "startChar": 61,
        "endLine": 20,
        "endChar": 74
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d1469641_4ca706a0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "Really neat, I am just concerned about performance, see my comments.",
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0808e827_083880ea",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-18T08:48:31Z",
      "side": 1,
      "message": "If the `membershipOf()` is called 1k times per second, we should perform this put to the cache 1k times per second as well, which is:\n- Unneeded (it is unlikely that anyone would mark inactive a user at msec level)\n- Expensive (the cache is persistent, therefore the put will be done to the underlying filesystem or other storage)\n\nWe should store the new value with some throttling (e.g. store at most once per minute)\n\nAlso, we do not need the activity precision at msec level on the cache.",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37c9a851_d01dda61",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-18T13:53:00Z",
      "side": 1,
      "message": "For a single user the `membershipsOf` is called:\n* 6x during the UI sign in\n* 17x when navigating to an open change in UI\n* 1x during SSH clone\n\nIn a single request, we won\u0027t call it thousands of times for the same user.\n\nBear in mind, that any _complexity_ we add to `membershipsOf` will have a negative performance effect on the overall group resolution. That\u0027s why I went with such a simplistic implementation.\n\nSure we can add throttling to limit the load on cache. I\u0027m concerned that it could be a premature optimization, as we don\u0027t know how this will perform in real instances and if it will have any noticeable impact on the performance.\n\nbtw. Isn\u0027t the persistent caching using batching to flush data to the persistent cache?",
      "parentUuid": "0808e827_083880ea",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b22fde3_cabd741d",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-19T23:54:33Z",
      "side": 1,
      "message": "\u003e btw. Isn\u0027t the persistent caching using batching to flush data to the persistent cache?\n\nWell, you don\u0027t know the implementation: it is pluggable. 17 times a 100msec latency is 1.7s added latency to open a change in the UI, which is significant.\n\nAlso tracking a msec activity isn\u0027t really useful: it is very unlikely that a user will be flagged as inactive after 100 msec of inactivity.",
      "parentUuid": "37c9a851_d01dda61",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4406e0ab_543aba41",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-20T00:07:41Z",
      "side": 1,
      "message": "\u003e Well, you don\u0027t know the implementation: it is pluggable. 17 times a 100msec latency is 1.7s added latency to open a change in the UI, which is significant.\n\nBTW. the latest implementation is using a private cache for throttling calls to the persistent cache, so this should not be a concern now.\n\n \u003e Also tracking a msec activity isn\u0027t really useful: it is very unlikely that a user will be flagged as inactive after 100 msec of inactivity.\n\nRight, it isn\u0027t _useful_, but it also doesn\u0027t cost us anything. We can divide the `currentTimeMillis` by `60_000` but that would add a neglectable CPU cycle ;). Sure _nobody_ cares about the milliseconds, but it\u0027s no cost for us IMO.",
      "parentUuid": "9b22fde3_cabd741d",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40a7e07b_1846e32d",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-27T00:18:51Z",
      "side": 1,
      "message": "\u003e \u003e Well, you don\u0027t know the implementation: it is pluggable. 17 times a 100msec latency is 1.7s added latency to open a change in the UI, which is significant.\n\u003e \n\u003e BTW. the latest implementation is using a private cache for throttling calls to the persistent cache, so this should not be a concern now.\n\nWell, that looks overkill IMHO. If you just reduce the precision to minutes, then you just don\u0027t store anything new if the latest activity time did not change. That effectively does throttling as you did already, but without introducing yet another cache.",
      "parentUuid": "4406e0ab_543aba41",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6899a246_1b4d8fd6",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-03-27T06:51:45Z",
      "side": 1,
      "message": "\u003e Well, that looks overkill IMHO. If you just reduce the precision to minutes, then you just don\u0027t store anything new if the latest activity time did not change. That effectively does throttling as you did already, but without introducing yet another cache.\n\nSure, but wouldn\u0027t that hammer the persistent cache anyway? Like, wouldn\u0027t it store the entry without checking if it\u0027s equal, this way we\u0027ll have the same IO load, but the values we store will be the same.",
      "parentUuid": "40a7e07b_1846e32d",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fce217f_11d18634",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-04-16T23:04:22Z",
      "side": 1,
      "message": "\u003e \u003e Well, that looks overkill IMHO. If you just reduce the precision to minutes, then you just don\u0027t store anything new if the latest activity time did not change. That effectively does throttling as you did already, but without introducing yet another cache.\n\u003e \n\u003e Sure, but wouldn\u0027t that hammer the persistent cache anyway?\n\nPlease look at the implementation of persistent caches 🙏 and see if that really applies or not.\n\nEvery persistent cache *has also* an in-memory cache: reading is from memory, storing is on disk.",
      "parentUuid": "6899a246_1b4d8fd6",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0e90740_80e00006",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-04-17T12:41:38Z",
      "side": 1,
      "message": "\u003e Please look at the implementation of persistent caches 🙏 and see if that really applies or not.\n\nSure, looking at `H2CacheImpl.put(K key, V val)`, in L#183, it will put the value into the memory cache, but then in L#184 it will _put value into H2 in background_. I don\u0027t see any code that would read and compare the current value with the value that is being set.\n\n\u003e Every persistent cache has also an in-memory cache: reading is from memory, storing is on disk.\n\nYes, it has an in-memory cache, but it won\u0027t prevent executing a `put` operation into the cache. Also, as the persistent part needs to track the last read/write, even when we insert the same value, the write timestamp will be updated, resulting in an IO.\n\nFrom that investigation, it\u0027s clear that we need to keep that in-memory cache here to prevent hammering the persistence layer with updates.",
      "parentUuid": "0fce217f_11d18634",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d49e3fd_946fa058",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-04-17T12:57:35Z",
      "side": 1,
      "message": "\u003e \u003e Please look at the implementation of persistent caches 🙏 and see if that really applies or not.\n\u003e \n\u003e Sure, looking at `H2CacheImpl.put(K key, V val)`, in L#183, it will put the value into the memory cache, but then in L#184 it will _put value into H2 in background_. I don\u0027t see any code that would read and compare the current value with the value that is being set.\n\nI am referring to get, not to put. If you get from the persistent cache, you\u0027ll get from memory, not from disk.\n\nYou put on the cache only if:\n- it isn\u0027t in the cache yet, get() returns null\n- the current value is greater than the one of the get()\n\nThen, because there isn\u0027t anyone willing to disable a user inactive by 1 msec, you just approximate (e.g. timestamp / 60000), and there will be at most one update per minute per user.\n\n\u003e \u003e Every persistent cache has also an in-memory cache: reading is from memory, storing is on disk.\n\u003e \n\u003e Yes, it has an in-memory cache, but it won\u0027t prevent executing a `put` operation into the cache. Also, as the persistent part needs to track the last read/write, even when we insert the same value, the write timestamp will be updated, resulting in an IO.\n\u003e \n\u003e From that investigation, it\u0027s clear that we need to keep that in-memory cache here to prevent hammering the persistence layer with updates.\n\nNot really, do you want me to provide an example?",
      "parentUuid": "e0e90740_80e00006",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb8e9a9a_588567a9",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-04-17T13:19:23Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Please look at the implementation of persistent caches 🙏 and see if that really applies or not.\n\u003e \u003e \n\u003e \u003e Sure, looking at `H2CacheImpl.put(K key, V val)`, in L#183, it will put the value into the memory cache, but then in L#184 it will _put value into H2 in background_. I don\u0027t see any code that would read and compare the current value with the value that is being set.\n\u003e \n\u003e I am referring to get, not to put. If you get from the persistent cache, you\u0027ll get from memory, not from disk.\n\u003e \n\u003e You put on the cache only if:\n\u003e - it isn\u0027t in the cache yet, get() returns null\n\u003e - the current value is greater than the one of the get()\n\u003e \n\u003e Then, because there isn\u0027t anyone willing to disable a user inactive by 1 msec, you just approximate (e.g. timestamp / 60000), and there will be at most one update per minute per user.\n\nYou\u0027re right, if we\u0027re talking about the \"read first, and compare\" approach. The only downside that I can think of, is the fact that \"now and then\" we\u0027ll do an IO-read from the persisted cache. That\u0027s probably \"implementation\" and \"system\" detail, what\u0027s _cheaper_ either do the IO or keep a throttling cache in memory ;)\n\nI\u0027ll refactor this to use the \"get and compare\" approach with one minute resolution.",
      "parentUuid": "9d49e3fd_946fa058",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7731d94_52ae43f0",
        "filename": "admin/track-active-users.groovy",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-04-17T17:06:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eb8e9a9a_588567a9",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 66,
        "endChar": 5
      },
      "revId": "eac6362056c2686e6a9e5bcfac89c56add4adc29",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}